<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System;
using System.Net.Http;
using CoinGecko.Clients;
using CoinGecko.Interfaces;
using Microsoft.Extensions.DependencyInjection;
using Polly;
using Polly.Contrib.WaitAndRetry;
using Polly.Extensions.Http;
using Serilog;

<# var nameSpace = "Trakx.CoinGecko.ApiClient"; #>

namespace <#= nameSpace #>
{
    public static partial class AddCoinGeckoApiClientExtension
    {
        private static void AddClients(this IServiceCollection services, CoinGeckoApiConfiguration configuration)
        {
            var delay = Backoff.DecorrelatedJitterBackoffV2(
                medianFirstRetryDelay: TimeSpan.FromMilliseconds(configuration.InitialRetryDelayInMilliseconds ?? 100), 
                retryCount: configuration.MaxRetryCount ?? 10, fastFirst: true);

            var handler = new ThrottledHttpClientHandler(configuration.ThrottleDelayPerSecond ?? 100);
            <# 
            var clientNames = new [] { "CoinsClient", "SimpleClient"};

            foreach(var name in clientNames)
            {
            #>
                        
            services.AddHttpClient<I<#= name #>, <#= name #>>("<#= nameSpace #>.<#= name #>")
                .ConfigurePrimaryHttpMessageHandler(() => handler)
                .AddPolicyHandler((s, request) => 
                    Policy<HttpResponseMessage>
                    .Handle<HttpRequestException>()
                    .OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.TooManyRequests)
                    .OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.Unauthorized)
                    .OrResult(msg => msg.StatusCode == System.Net.HttpStatusCode.Forbidden)
                    .Or<HttpRequestException>()
                    .OrTransientHttpStatusCode()
                    .WaitAndRetryAsync(delay,
                        onRetry: (result, timeSpan, retryCount, context) =>
                        {
                            var logger = Log.Logger.ForContext<<#= name #>>();
                            LogFailure(logger, result, timeSpan, retryCount, context);
                        })
                    .WithPolicyKey("<#= nameSpace #>.<#= name #>"));

        <#
        }
        #>
}
    }
}